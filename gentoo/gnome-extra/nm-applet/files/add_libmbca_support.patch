---
 configure.ac                               |   10 +
 src/applet-device-gsm.c                    |  233 ++++++++++++++++++++++++++++-
 src/applet.c                               |   51 ++++++
 src/applet.h                               |   32 +++
 src/connection-editor/nm-connection-list.c |  200 ++++++++++++++++++++++++
 src/connection-editor/nm-connection-list.h |   14 +
 6 files changed, 538 insertions(+), 2 deletions(-)

Index: network-manager-applet-0.7.1~rc4/src/applet-device-gsm.c
===================================================================
--- network-manager-applet-0.7.1~rc4.orig/src/applet-device-gsm.c
+++ network-manager-applet-0.7.1~rc4/src/applet-device-gsm.c
@@ -35,42 +35,238 @@
 #include <nm-setting-ppp.h>
 #include <nm-gsm-device.h>
 #include <nm-utils.h>
 
 #include "applet.h"
 #include "applet-device-gsm.h"
 #include "utils.h"
 
+#ifdef WITH_MBCA
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <nm-setting-ip4-config.h>
+#include <nm-utils.h>
+#endif
+
 typedef struct {
 	NMApplet *applet;
 	NMDevice *device;
 	NMConnection *connection;
 } GSMMenuItemInfo;
 
 static void
 gsm_menu_item_info_destroy (gpointer data)
 {
 	g_slice_free (GSMMenuItemInfo, data);
 }
 
+#ifdef WITH_MBCA
+static void
+assistant_state_changed_cb (MBCAAssistant* assistant,
+					   MBCAAssistantState state,
+					   gpointer data)
+{
+	NMApplet *applet = data;
+	GSList* iter;
+
+	NMAGConfConnection *exported;
+
+	NMConnection *connection;
+	NMSettingGsm *s_gsm;
+	NMSettingSerial *s_serial;
+	NMSettingPPP *s_ppp;
+	NMSettingConnection *s_con;
+
+	NMSettingIP4Config* ipv4conf;
+	gboolean ignore_auto_dns = FALSE;
+	GArray *dns_servers = FALSE;
+	const char *method;
+
+	MBCAConfiguration* conf;
+
+	if (!applet_open_mbca (applet))
+		g_return_if_reached (); /* this cb should not be called without
+							* libmbca */
+
+	switch (state)
+	{
+		case MBCA_STATE_READY:
+		case MBCA_STATE_RUNNING:
+		{
+			break;
+		}
+		case MBCA_STATE_DONE:
+		{
+			conf = applet->mbca_assistant_get_configuration_func (assistant);
+			connection = nm_connection_new ();
+
+			s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
+			nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+			ipv4conf = NM_SETTING_IP4_CONFIG (nm_setting_ip4_config_new ());
+			nm_connection_add_setting (connection, NM_SETTING (ipv4conf));
+
+			g_object_set (G_OBJECT(s_con),
+					    "id", conf->name,
+					    "type", NM_SETTING_GSM_SETTING_NAME,
+					    "uuid", nm_utils_uuid_generate (),
+					    "autoconnect", FALSE,
+					    NULL);
+
+			/* Serial setting */
+			s_serial = (NMSettingSerial *) nm_setting_serial_new ();
+			g_object_set (G_OBJECT(s_serial),
+					    "baud", 115200,
+					    "bits", 8,
+					    "parity", "n",
+					    "stopbits", 1,
+					    NULL);
+			nm_connection_add_setting (connection, NM_SETTING (s_serial));
+
+			method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
+
+			s_gsm = NM_SETTING_GSM (nm_setting_gsm_new ());
+
+			g_object_set (G_OBJECT(s_gsm),
+					    "number", "*99#",
+					    "apn", conf->provider->gsm.apn,
+					    "username", conf->provider->username,
+					    "password", conf->provider->password,
+					    NULL);
+
+			if (conf->provider->dns1) {
+				struct in_addr tmp_addr;
+				ignore_auto_dns = TRUE;
+				dns_servers = g_array_new (FALSE, FALSE, sizeof (guint));
+
+				inet_aton (conf->provider->dns1, &tmp_addr);
+				g_array_append_val (dns_servers, tmp_addr.s_addr);
+
+				if (conf->provider->dns2) {
+					inet_aton (conf->provider->dns2, &tmp_addr);
+					g_array_append_val (dns_servers, tmp_addr.s_addr);
+				}
+			}
+
+			/* TODO: gateway */
+
+			g_object_set (ipv4conf,
+					    NM_SETTING_IP4_CONFIG_METHOD, method,
+					    NM_SETTING_IP4_CONFIG_DNS, dns_servers,
+					    NM_SETTING_IP4_CONFIG_IGNORE_AUTO_DNS, ignore_auto_dns,
+					    NULL);
+
+			nm_connection_add_setting (connection, NM_SETTING (s_gsm));
+
+			s_ppp = (NMSettingPPP *) nm_setting_ppp_new ();
+			nm_connection_add_setting (connection, NM_SETTING (s_ppp));
+
+
+			applet->mbca_free_configuration_func (conf);
+			if (dns_servers)
+				g_array_free (dns_servers, TRUE);
+
+			exported = nma_gconf_settings_add_connection (applet->gconf_settings, connection);
+			if (!exported) {
+				g_object_unref (connection);
+				g_return_if_reached ();
+			}
+			g_object_unref (connection);
+
+			applet_do_notify (applet, NOTIFY_URGENCY_LOW,
+						   _("New Configuration Created"),
+						   _("You can activate the connection by clicking this icon.\n"
+							"\n"
+							"Use connection editor to add new and to change settings if necessary"),
+						   "nm-device-wwan", NULL, NULL, NULL, NULL);
+
+			/* FALLTHROUGH */
+		}
+		case MBCA_STATE_ABORTED:
+		{
+			for (iter = applet->mbca_assistants; iter; iter = iter->next){
+				if (((UdiAssistant*)(iter->data))->assistant == assistant) {
+					UdiAssistant* ua = iter->data;
+					applet->mbca_assistants = g_slist_remove_all (applet->mbca_assistants,
+														 ua);
+
+					g_object_unref (G_OBJECT (ua->assistant));
+					g_free (ua->udi);
+					g_free (ua);
+
+				}
+			}
+			break;
+		}
+		default:
+		{
+			g_return_if_reached ();
+		}
+	}
+}
+#endif
+
 #define DEFAULT_GSM_NAME _("Auto Mobile Broadband (GSM) connection")
 
 static NMConnection *
 gsm_new_auto_connection (NMDevice *device,
                          NMApplet *applet,
                          gpointer user_data)
 {
 	NMConnection *connection;
 	NMSettingGsm *s_gsm;
 	NMSettingSerial *s_serial;
 	NMSettingPPP *s_ppp;
 	NMSettingConnection *s_con;
 	char *uuid;
 
+#ifdef WITH_MBCA
+	UdiAssistant* ua;
+	const gchar* udi;
+	GSList* iter;
+
+	if (applet_open_mbca (applet))
+	{
+		udi = nm_device_get_udi (device);
+
+		for (iter = applet->mbca_assistants; iter; iter = iter->next) {
+			UdiAssistant* tmp = iter->data;
+			if (!strcmp (tmp->udi, udi))
+			{
+				applet->mbca_assistant_present_func (tmp->assistant);
+				break;
+			}
+		}
+		if (!iter)
+		{
+			/* not found */
+			ua = g_malloc (sizeof (UdiAssistant));
+			ua->udi = g_strdup (udi);
+			ua->assistant = applet->mbca_assistant_new_func ();
+			g_signal_connect (G_OBJECT (ua->assistant), "state-changed",
+						   G_CALLBACK (assistant_state_changed_cb), applet);
+			applet->mbca_assistants = g_slist_prepend (applet->mbca_assistants, ua);
+			applet->mbca_assistant_run_for_device_func (ua->assistant,
+											    MBCA_DEVICE_PSEUDO,
+											    NULL, NULL);
+		}
+
+		nm_warning ("There's a new GSM modem being configured and no "
+				  "configuration is yet available. You can safely ignore the "
+				  "next warninig, if any, about missing default configuration."
+				  );
+		return NULL;
+	}
+	else
+	{
+		/* continue to default code */
+	}
+#endif
+
 	connection = nm_connection_new ();
 
 	s_gsm = NM_SETTING_GSM (nm_setting_gsm_new ());
 	/* This should be a sensible default as it's seems to be quite standard */
 	g_object_set (s_gsm, NM_SETTING_GSM_NUMBER, "*99#", NULL);
 	nm_connection_add_setting (connection, NM_SETTING (s_gsm));
 
 	/* Serial setting */
@@ -150,19 +346,25 @@
 }
 
 static void
 add_default_connection_item (NMDevice *device,
                              GtkWidget *menu,
                              NMApplet *applet)
 {
 	GSMMenuItemInfo *info;
-	GtkWidget *item;
+	GtkWidget *item = NULL;
+
+#ifdef WITH_MBCA
+	if (applet_open_mbca (applet))
+		item = gtk_check_menu_item_new_with_label (_("Configure..."));
+#endif
+	if (!item)
+		item = gtk_check_menu_item_new_with_label (DEFAULT_GSM_NAME);
 	
-	item = gtk_check_menu_item_new_with_label (DEFAULT_GSM_NAME);
 	gtk_check_menu_item_set_draw_as_radio (GTK_CHECK_MENU_ITEM (item), TRUE);
 
 	info = g_slice_new0 (GSMMenuItemInfo);
 	info->applet = applet;
 	info->device = g_object_ref (G_OBJECT (device));
 
 	g_signal_connect_data (item, "activate",
 	                       G_CALLBACK (gsm_menu_item_activate),
@@ -303,16 +505,39 @@
 		                            _("Connection Established"),
 		                            str ? str : _("You are now connected to the GSM network."),
 		                            "nm-device-wwan",
 		                            PREF_DISABLE_CONNECTED_NOTIFICATIONS);
 		g_free (str);
 	}
 }
 
+#ifdef WITH_MBCA
+typedef struct {
+	NMDevice* device;
+	NMApplet* applet;
+} NotifyConfigureNewDeviceCbData;
+
+static void
+gsm_device_added (NMDevice *device, NMApplet *applet)
+{
+	GSList *connections, *all;
+
+	if (!applet_open_mbca (applet))
+		return;
+
+	all = applet_get_all_connections (applet);
+	connections = utils_filter_connections_for_device (device, all);
+	g_slist_free (all);
+
+	if (g_slist_length (connections) == 0)
+		gsm_new_auto_connection (device, applet, NULL);
+}
+#endif
+
 static GdkPixbuf *
 gsm_get_icon (NMDevice *device,
               NMDeviceState state,
               NMConnection *connection,
               char **tip,
               NMApplet *applet)
 {
 	NMSettingConnection *s_con;
@@ -649,11 +874,15 @@
 		return NULL;
 
 	dclass->new_auto_connection = gsm_new_auto_connection;
 	dclass->add_menu_item = gsm_add_menu_item;
 	dclass->device_state_changed = gsm_device_state_changed;
 	dclass->get_icon = gsm_get_icon;
 	dclass->get_secrets = gsm_get_secrets;
 
+#ifdef WITH_MBCA
+	dclass->device_added = gsm_device_added;
+#endif
+
 	return dclass;
 }
 
Index: network-manager-applet-0.7.1~rc4/src/applet.c
===================================================================
--- network-manager-applet-0.7.1~rc4.orig/src/applet.c
+++ network-manager-applet-0.7.1~rc4/src/applet.c
@@ -1022,16 +1022,62 @@
 		item = gtk_menu_item_new_with_label (_("device not managed"));
 
 	if (item)
 		gtk_widget_set_sensitive (item, FALSE);
 
 	return item;
 }
 
+#ifdef WITH_MBCA
+gboolean
+applet_open_mbca (NMApplet *applet)
+{
+	if (applet->mbca_module)
+		return TRUE;
+
+	applet->mbca_module = g_module_open ("libmbca.so.0", G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);
+	if (!applet->mbca_module)
+		return FALSE;
+
+	if (!g_module_symbol (applet->mbca_module,
+						  "mbca_assistant_abort",
+						  ((gpointer)(&applet->mbca_assistant_abort_func))))
+		g_warn_if_reached ();
+
+	if (!g_module_symbol (applet->mbca_module,
+						  "mbca_assistant_present",
+						  (gpointer)(&applet->mbca_assistant_present_func)))
+		g_warn_if_reached ();
+
+	if (!g_module_symbol (applet->mbca_module,
+						  "mbca_assistant_new",
+						  (gpointer)(&applet->mbca_assistant_new_func)))
+		g_warn_if_reached ();
+
+	if (!g_module_symbol (applet->mbca_module,
+						  "mbca_assistant_run_for_device",
+						  (gpointer)(&applet->mbca_assistant_run_for_device_func)))
+		g_warn_if_reached ();
+
+	if (!g_module_symbol (applet->mbca_module,
+						  "mbca_assistant_get_configuration",
+						  (gpointer)(&applet->mbca_assistant_get_configuration_func)))
+		g_warn_if_reached ();
+
+	if (!g_module_symbol (applet->mbca_module,
+						  "mbca_free_configuration",
+						  (gpointer)(&applet->mbca_free_configuration_func)))
+		g_warn_if_reached ();
+
+	return TRUE;
+}
+#endif
+
+
 static guint32
 nma_menu_add_devices (GtkWidget *menu, NMApplet *applet)
 {
 	const GPtrArray *temp = NULL;
 	GSList *devices = NULL, *iter = NULL;
 	gint n_wifi_devices = 0;
 	gint n_usable_wifi_devices = 0;
 	gint n_wired_devices = 0;
@@ -2626,16 +2672,21 @@
 
 static void nma_init (NMApplet *applet)
 {
 	applet->animation_id = 0;
 	applet->animation_step = 0;
 	applet->icon_theme = NULL;
 	applet->notification = NULL;
 	applet->size = -1;
+
+#ifdef WITH_MBCA
+	applet->mbca_assistants = NULL;
+	applet->mbca_module = NULL;
+#endif
 }
 
 enum {
 	PROP_0,
 	PROP_LOOP,
 	LAST_PROP
 };
 
Index: network-manager-applet-0.7.1~rc4/src/applet.h
===================================================================
--- network-manager-applet-0.7.1~rc4.orig/src/applet.h
+++ network-manager-applet-0.7.1~rc4/src/applet.h
@@ -42,26 +42,38 @@
 #include <nm-connection.h>
 #include <nm-client.h>
 #include <nm-access-point.h>
 #include <nm-device.h>
 #include <NetworkManager.h>
 #include <nm-active-connection.h>
 #include <nm-dbus-settings.h>
 
+#ifdef WITH_MBCA
+#include <mbca_assistant.h>
+#endif
+
 #include "applet-dbus-manager.h"
 #include "nma-gconf-settings.h"
 
 #define NM_TYPE_APPLET			(nma_get_type())
 #define NM_APPLET(object)		(G_TYPE_CHECK_INSTANCE_CAST((object), NM_TYPE_APPLET, NMApplet))
 #define NM_APPLET_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST((klass), NM_TYPE_APPLET, NMAppletClass))
 #define NM_IS_APPLET(object)		(G_TYPE_CHECK_INSTANCE_TYPE((object), NM_TYPE_APPLET))
 #define NM_IS_APPLET_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE((klass), NM_TYPE_APPLET))
 #define NM_APPLET_GET_CLASS(object)(G_TYPE_INSTANCE_GET_CLASS((object), NM_TYPE_APPLET, NMAppletClass))
 
+#ifdef WITH_MBCA
+typedef struct
+{
+	char* udi;
+	MBCAAssistant* assistant;
+} UdiAssistant;
+#endif
+
 typedef struct
 {
 	GObjectClass	parent_class;
 } NMAppletClass; 
 
 #define APPLET_PREFS_PATH "/apps/nm-applet"
 #define PREF_DISABLE_CONNECTED_NOTIFICATIONS	APPLET_PREFS_PATH "/disable-connected-notifications"
 #define PREF_DISABLE_DISCONNECTED_NOTIFICATIONS	APPLET_PREFS_PATH "/disable-disconnected-notifications"
@@ -139,16 +151,31 @@
 	GtkWidget *		wifi_enabled_item;
 	guint           wifi_enabled_toggled_id;
 	GtkWidget *		info_menu_item;
 	GtkWidget *		connections_menu_item;
 
 	GladeXML *		info_dialog_xml;
 	NotifyNotification*	notification;
 	gboolean		notify_with_actions;
+
+
+#ifdef WITH_MBCA
+	GSList *mbca_assistants; /* list of UdiAssistant */
+	GModule *mbca_module;
+	void (*mbca_assistant_abort_func) (MBCAAssistant*);
+	void (*mbca_assistant_present_func) (MBCAAssistant*);
+	MBCAAssistant* (*mbca_assistant_new_func) ();
+	gint (*mbca_assistant_run_for_device_func) (MBCAAssistant*,
+									    MBCADeviceType,
+									    const gchar*,
+									    const gchar*);
+	MBCAConfiguration* (*mbca_assistant_get_configuration_func) (MBCAAssistant*);
+	void (*mbca_free_configuration_func) (MBCAConfiguration*);
+#endif
 } NMApplet;
 
 
 struct NMADeviceClass {
 	NMConnection * (*new_auto_connection)  (NMDevice *device,
 	                                        NMApplet *applet,
 	                                        gpointer user_data);
 
@@ -221,11 +248,16 @@
 void applet_do_notify_with_pref (NMApplet *applet,
                                  const char *summary,
                                  const char *message,
                                  const char *icon,
                                  const char *pref);
 
 NMConnection * applet_find_active_connection_for_device (NMDevice *device,
                                                          NMApplet *applet,
+
                                                          NMActiveConnection **out_active);
 
+#ifdef WITH_MBCA
+gboolean applet_open_mbca (NMApplet *applet);
+#endif
+
 #endif
Index: network-manager-applet-0.7.1~rc4/src/connection-editor/nm-connection-list.c
===================================================================
--- network-manager-applet-0.7.1~rc4.orig/src/connection-editor/nm-connection-list.c
+++ network-manager-applet-0.7.1~rc4/src/connection-editor/nm-connection-list.c
@@ -46,16 +46,23 @@
 #include <nm-setting-gsm.h>
 #include <nm-setting-cdma.h>
 #include <nm-setting-pppoe.h>
 #include <nm-setting-ppp.h>
 #include <nm-setting-serial.h>
 #include <nm-vpn-plugin-ui-interface.h>
 #include <nm-utils.h>
 
+#ifdef WITH_MBCA
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <nm-setting-ip4-config.h>
+#include <nm-utils.h>
+#endif
+
 #include "nm-connection-editor.h"
 #include "nm-connection-list.h"
 #include "gconf-helpers.h"
 #include "mobile-wizard.h"
 #include "utils.h"
 #include "vpn-helpers.h"
 #include "polkit-helpers.h"
 
@@ -103,16 +110,52 @@
 	g_free (message);
 
 	gtk_widget_show_all (dialog);
 	gtk_window_present (GTK_WINDOW (dialog));
 	gtk_dialog_run (GTK_DIALOG (dialog));
 	gtk_widget_destroy (dialog);
 }
 
+#ifdef WITH_MBCA
+static gboolean
+open_mbca (NMConnectionList *list)
+{
+	if (list->mbca_module)
+		return TRUE;
+
+	list->mbca_module = g_module_open ("libmbca.so.0", G_MODULE_BIND_LAZY |
+											 G_MODULE_BIND_LOCAL);
+	if (!list->mbca_module)
+		return FALSE;
+
+	if (!g_module_symbol (list->mbca_module,
+					  "mbca_assistant_new",
+					  (gpointer)(&list->mbca_assistant_new_func)));
+		g_warn_if_reached ();
+
+	if (!g_module_symbol (list->mbca_module,
+					  "mbca_assistant_run_for_device",
+					  (gpointer)(&list->mbca_assistant_run_for_device_func)));
+		g_warn_if_reached ();
+
+	if (!g_module_symbol (list->mbca_module,
+					  "mbca_assistant_get_configuration",
+					  (gpointer)(&list->mbca_assistant_get_configuration_func)));
+		g_warn_if_reached ();
+
+	if (!g_module_symbol (list->mbca_module,
+					  "mbca_free_configuration",
+					  (gpointer)(&list->mbca_free_configuration_func)));
+		g_warn_if_reached ();
+
+	return TRUE;
+}
+#endif
+
 static NMExportedConnection *
 get_active_connection (GtkTreeView *treeview)
 {
 	GtkTreeSelection *selection;
 	GList *selected_rows;
 	GtkTreeModel *model = NULL;
 	GtkTreeIter iter;
 	NMExportedConnection *exported = NULL;
@@ -814,25 +857,155 @@
 	              NM_SETTING_SERIAL_BITS, 8,
 	              NM_SETTING_SERIAL_PARITY, 'n',
 	              NM_SETTING_SERIAL_STOPBITS, 1,
 	              NULL);
 
 	nm_connection_add_setting (connection, NM_SETTING (s_serial));
 }
 
+#ifdef WITH_MBCA
+static void
+mbca_assistant_state_changed_cb (MBCAAssistant* assistant,
+						   MBCAAssistantState state,
+						   gpointer user_data)
+{
+	NMConnection *connection = NULL;
+	NMSettingConnection *s_con;
+	NMSetting *type_setting = NULL;
+	MBCAConfiguration* conf;
+
+	NMConnectionList *list = user_data;
+
+	NMSettingIP4Config* ipv4conf;
+	gboolean ignore_auto_dns = FALSE;
+	GArray *dns_servers = FALSE;
+	const char *method;
+
+	switch (state) {
+	case MBCA_STATE_READY:
+	case MBCA_STATE_RUNNING:
+		return;
+	case MBCA_STATE_DONE:
+
+		/* this function should never get called without a prior usage of
+		 * libmbca in create_new_connection_for_type
+		 */
+		g_return_if_fail (open_mbca (list));
+
+		connection = nm_connection_new ();
+		nm_connection_set_scope (connection, NM_CONNECTION_SCOPE_USER);
+
+		s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
+		nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+		ipv4conf = NM_SETTING_IP4_CONFIG (nm_setting_ip4_config_new ());
+		nm_connection_add_setting (connection, NM_SETTING (ipv4conf));
+
+		conf = list->mbca_assistant_get_configuration_func (assistant);
+
+		g_object_set (G_OBJECT (s_con),
+				    "uuid", nm_utils_uuid_generate (),
+				    "id", conf->name,
+				    "autoconnect", FALSE,
+				    NULL);
+
+		add_default_serial_setting (connection);
+
+		method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
+
+		if (conf->provider->type == MBCA_NETWORK_GSM) {
+			NMSettingGsm *s_gsm;
+
+			g_object_set (G_OBJECT(s_con),
+					    "type", NM_SETTING_GSM_SETTING_NAME,
+					    NULL);
+
+			type_setting = nm_setting_gsm_new ();
+			s_gsm = NM_SETTING_GSM (type_setting);
+			g_object_set(G_OBJECT(s_gsm),
+					   "number", "*99#" /* De-facto standard for GSM */,
+					   "apn", conf->provider->gsm.apn,
+					   "username", conf->provider->username,
+					   "password", conf->provider->password,
+					   NULL);
+
+			if (conf->provider->dns1) {
+				struct in_addr tmp_addr;
+				ignore_auto_dns = TRUE;
+				dns_servers = g_array_new (FALSE, FALSE, sizeof (guint));
+
+				inet_aton (conf->provider->dns1, &tmp_addr);
+				g_array_append_val (dns_servers, tmp_addr.s_addr);
+
+				if (conf->provider->dns2) {
+					inet_aton (conf->provider->dns2, &tmp_addr);
+					g_array_append_val (dns_servers, tmp_addr.s_addr);
+				}
+			}
+
+			/* TODO: gateway */
+
+		} else if (conf->provider->type == MBCA_NETWORK_CDMA) {
+			g_object_set (G_OBJECT (s_con),
+					    "type", NM_SETTING_CDMA_SETTING_NAME,
+					    NULL);
+
+			type_setting = nm_setting_cdma_new ();
+			g_object_set (G_OBJECT (type_setting),
+					    "number", "#777" /* De-facto standard for CDMA */,
+					    "username", conf->provider->username,
+					    "password", conf->provider->password,
+					    NULL);
+		}
+		nm_connection_add_setting (connection, nm_setting_ppp_new ());
+
+		g_object_set (ipv4conf,
+				    NM_SETTING_IP4_CONFIG_METHOD, method,
+				    NM_SETTING_IP4_CONFIG_DNS, dns_servers,
+				    NM_SETTING_IP4_CONFIG_IGNORE_AUTO_DNS, ignore_auto_dns,
+				    NULL);
+
+		if (type_setting) {
+			nm_connection_add_setting (connection, type_setting);
+		} else {
+			g_object_unref (connection);
+			connection = NULL;
+		}
+
+		add_connection (list, NULL, connection, NULL, NULL);
+		g_hash_table_remove (list->editors, connection);
+
+		list->mbca_free_configuration_func (conf);
+		if (dns_servers)
+			g_array_free (dns_servers, TRUE);
+		/* FALLTHROUGH */
+
+	case MBCA_STATE_ABORTED:
+		g_object_unref (assistant);
+		break;
+	default:
+		g_warn_if_reached ();
+	}
+}
+#endif
+
 static NMConnection *
 create_new_connection_for_type (NMConnectionList *list, const char *connection_type)
 {
 	GType ctype;
 	NMConnection *connection = NULL;
 	NMSettingConnection *s_con;
 	NMSetting *type_setting = NULL;
 	char *id, *uuid;
 	GType mb_type;
+#ifdef WITH_MBCA
+	MBCAAssistant *assistant = NULL;
+	gboolean use_mbca = FALSE;
+#endif
 
 	ctype = nm_connection_lookup_setting_type (connection_type);
 
 	connection = nm_connection_new ();
 	nm_connection_set_scope (connection, NM_CONNECTION_SCOPE_USER);
 	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
 	uuid = nm_utils_uuid_generate ();
 	g_object_set (s_con, NM_SETTING_CONNECTION_UUID, uuid, NULL);
@@ -859,16 +1032,20 @@
 		              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
 		              NULL);
 		g_free (id);
 
 		type_setting = nm_setting_wireless_new ();
 		s_wireless = NM_SETTING_WIRELESS (type_setting);
 		g_object_set (s_wireless, NM_SETTING_WIRELESS_MODE, "infrastructure", NULL);
 	} else if ((ctype == NM_TYPE_SETTING_GSM) || (ctype == NM_TYPE_SETTING_CDMA)) {
+#ifdef WITH_MBCA
+		use_mbca = open_mbca (list);
+		if (!use_mbca) {
+#endif
 		/* Since GSM is a placeholder for both GSM and CDMA; ask the user which
 		 * one they really want.
 		 */
 		mb_type = mobile_wizard_ask_connection_type ();
 		if (mb_type == NM_TYPE_SETTING_GSM) {
 			NMSettingGsm *s_gsm;
 
 			id = get_next_available_name (list, _("GSM connection %d"));
@@ -905,16 +1082,30 @@
 
 			/* De-facto standard for CDMA */
 			g_object_set (s_cdma, NM_SETTING_CDMA_NUMBER, "#777", NULL);
 
 			nm_connection_add_setting (connection, nm_setting_ppp_new ());
 		} else {
 			/* user canceled; do nothing */
 		}
+#ifdef WITH_MBCA
+		} else { /* use_mbca */
+
+			assistant = list->mbca_assistant_new_func ();
+			g_signal_connect (G_OBJECT (assistant), "state-changed",
+						   G_CALLBACK (mbca_assistant_state_changed_cb), list);
+			list->mbca_assistant_run_for_device_func (assistant,
+											  MBCA_DEVICE_PSEUDO,
+											  NULL, NULL);
+
+			mb_type = NM_TYPE_SETTING_GSM; /* get rid of compiler warning about
+									  * unused variable */
+		}
+#endif /* WITH_MBCA */
 	} else if (ctype == NM_TYPE_SETTING_VPN) {
 		char *service = NULL;
 
 		service = vpn_ask_connection_type ();
 		if (service) {
 			NMSettingVPN *s_vpn;
 
 			id = get_next_available_name (list, _("VPN connection %d"));
@@ -1415,16 +1606,20 @@
 
 static void
 nm_connection_list_init (NMConnectionList *list)
 {
 	list->treeviews = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
 
 	list->system_action = polkit_action_new ();
 	polkit_action_set_action_id (list->system_action, "org.freedesktop.network-manager-settings.system.modify");
+
+#ifdef WITH_MBCA
+	list->mbca_module = NULL;
+#endif
 }
 
 static void
 dispose (GObject *object)
 {
 	NMConnectionList *list = NM_CONNECTION_LIST (object);
 
 	if (list->dialog)
@@ -1456,16 +1651,21 @@
 	g_hash_table_destroy (list->treeviews);
 
 	if (list->gconf_settings)
 		g_object_unref (list->gconf_settings);
 
 	if (list->system_settings)
 		g_object_unref (list->system_settings);
 
+#if WITH_MBCA
+	if (list->mbca_module)
+		g_module_close (list->mbca_module);
+#endif
+
 	G_OBJECT_CLASS (nm_connection_list_parent_class)->dispose (object);
 }
 
 static void
 nm_connection_list_class_init (NMConnectionListClass *klass)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
Index: network-manager-applet-0.7.1~rc4/src/connection-editor/nm-connection-list.h
===================================================================
--- network-manager-applet-0.7.1~rc4.orig/src/connection-editor/nm-connection-list.h
+++ network-manager-applet-0.7.1~rc4/src/connection-editor/nm-connection-list.h
@@ -31,16 +31,20 @@
 #include <nm-dbus-settings-system.h>
 #ifdef NO_POLKIT_GNOME
 #include "polkit-gnome.h"
 #else
 #include <polkit-gnome/polkit-gnome.h>
 #endif
 #include "nma-gconf-settings.h"
 
+#ifdef WITH_MBCA
+#include <mbca_assistant.h>
+#endif
+
 #define NM_TYPE_CONNECTION_LIST    (nm_connection_list_get_type ())
 #define NM_IS_CONNECTION_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_CONNECTION_LIST))
 #define NM_CONNECTION_LIST(obj)    (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_CONNECTION_LIST, NMConnectionList))
 
 typedef struct {
 	GObject parent;
 
 	/* private data */
@@ -57,16 +61,26 @@
 	PolKitAction *system_action;
 
 	GdkPixbuf *wired_icon;
 	GdkPixbuf *wireless_icon;
 	GdkPixbuf *wwan_icon;
 	GdkPixbuf *vpn_icon;
 	GdkPixbuf *unknown_icon;
 	GtkIconTheme *icon_theme;
+#ifdef WITH_MBCA
+	GModule *mbca_module;
+	MBCAAssistant* (*mbca_assistant_new_func) ();
+	gint (*mbca_assistant_run_for_device_func) (MBCAAssistant*,
+									    MBCADeviceType,
+									    const gchar*,
+									    const gchar*);
+	MBCAConfiguration* (*mbca_assistant_get_configuration_func) (MBCAAssistant*);
+	void (*mbca_free_configuration_func) (MBCAConfiguration*);
+#endif
 } NMConnectionList;
 
 typedef struct {
 	GObjectClass parent_class;
 
 	/* Signals */
 	void (*done)  (NMConnectionList *list, gint result);
 } NMConnectionListClass;
Index: network-manager-applet-0.7.1~rc4/configure.ac
===================================================================
--- network-manager-applet-0.7.1~rc4.orig/configure.ac
+++ network-manager-applet-0.7.1~rc4/configure.ac
@@ -214,16 +214,26 @@
 		unset has_option
 		unset SAVE_CFLAGS
 	done
 	unset option
 else
 	AC_MSG_RESULT(no)
 fi
 
+AC_ARG_WITH(mbca, AC_HELP_STRING([--with-mbca], [use Mobile Broadband Configuration Assistant]))
+
+if ! test -z "$with_mbca" ; then
+    CFLAGS="$CFLAGS -DWITH_MBCA"
+    PKG_CHECK_MODULES(MBCA, libmbca)
+    NMA_CFLAGS="$NMA_CFLAGS $MBCA_CFLAGS"
+    #NMA_LIBS="$NMA_LIBS $MBCA_LIBS"
+fi
+
+
 AC_OUTPUT([
 Makefile
 src/Makefile
 src/marshallers/Makefile
 src/utils/Makefile
 src/gconf-helpers/Makefile
 src/wireless-security/Makefile
 src/polkit-helpers/Makefile
